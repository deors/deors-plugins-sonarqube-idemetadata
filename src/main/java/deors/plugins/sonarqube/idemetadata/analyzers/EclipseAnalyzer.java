package deors.plugins.sonarqube.idemetadata.analyzers;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import deors.plugins.sonarqube.idemetadata.model.ProjectInfo;

/**
 * Eclipse IDE Metadata Analyzer.
 *
 * This tool searches for project and classpath metadata generated by Eclipse IDE
 * and derived IDE's and extracts the project basic information and dependencies.
 * The tool detects Java, Web, EJB, EAR, Google Web Toolkit, Google App Engine,
 * Groovy, Grails, Eclipse PDE and Eclipse JET projects.
 *
 * @author jorge.hidalgo
 * @version 1.0
 */
public class EclipseAnalyzer {

    /**
     * The project root directory.
     */
    private final File rootDir;

    /**
     * Bean with analysis results.
     */
    private ProjectInfo projectInfo;

    /**
     * XPath expression used to parse Eclipse project files.
     */
    private static final String XPATH_PROJECT_NAME = "/projectDescription/name/text()"; //$NON-NLS-1$

    /**
     * XPath expression used to parse Eclipse project files.
     */
    private static final String XPATH_PROJECT_DEPENDENCIES = "/projectDescription/projects/project/text()"; //$NON-NLS-1$

    /**
     * XPath expression used to parse Eclipse project files.
     */
    private static final String XPATH_PROJECT_NATURES = "/projectDescription/natures/nature/text()"; //$NON-NLS-1$

    /**
     * XPath expression used to parse Eclipse facet config files.
     */
    private static final String XPATH_FACET_FIXED = "/faceted-project/fixed/@facet"; //$NON-NLS-1$

    /**
     * XPath expression used to parse Eclipse facet config files.
     */
    private static final String XPATH_FACET_INSTALLED = "/faceted-project/installed/@facet"; //$NON-NLS-1$

    /**
     * XPath expression used to parse Eclipse classpath files.
     */
    private static final String XPATH_CLASSPATH_LIB = "/classpath/classpathentry[@kind='lib']/@path"; //$NON-NLS-1$

    /**
     * XPath expression used to parse Eclipse classpath files.
     */
    private static final String XPATH_CLASSPATH_SRC = "/classpath/classpathentry[@kind='src']/@path"; //$NON-NLS-1$

    /**
     * The Eclipse project file name.
     */
    private static final String PROJECT_FILE = ".project"; //$NON-NLS-1$

    /**
     * The Eclipse classpath file name.
     */
    private static final String CLASSPATH_FILE = ".classpath"; //$NON-NLS-1$

    /**
     * The WST facet configuration file name.
     */
    private static final String FACET_CONFIG_FILE = ".settings\\org.eclipse.wst.common.project.facet.core.xml"; //$NON-NLS-1$

    /**
     * The logger.
     */
    private final Logger log = LoggerFactory.getLogger(this.getClass());

    /**
     * Analyzer constructor.
     *
     * @param rootDir the project root directory
     */
    public EclipseAnalyzer(final File rootDir) {
        super();
        this.rootDir = rootDir;
    }

    /**
     * Analyzes the metadata files.
     *
     * @return the project information extracted from metadata files
     * @throws AnalyzerException any error occurred while analyzing the metadata
     *                           files, typically a parsing error in XML files
     */
    public ProjectInfo analyze()
        throws AnalyzerException  {

        projectInfo = new ProjectInfo();

        analyzeProjectFile();
        analyzeFacetsFile();
        analyzeClasspathFile();

        return projectInfo;
    }

    /**
     * Analyzes the .project file.
     *
     * @throws AnalyzerException any error occurred while analyzing the metadata
     *                           files, typically a parsing error in XML files
     */
    private void analyzeProjectFile()
        throws AnalyzerException {

        List<String> projectDependencies = new ArrayList<>();
        List<String> projectNatures = new ArrayList<>();

        try {
            // parses .project file
            File projectFile = new File(rootDir, PROJECT_FILE);
            if (!projectFile.exists()) {
                return;
            }

            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            factory.setNamespaceAware(true);
            DocumentBuilder builder = factory.newDocumentBuilder();
            XPathFactory xpathFactory = XPathFactory.newInstance();
            XPath xpath = xpathFactory.newXPath();

            Document projectDocument = builder.parse(projectFile);

            // gets project name
            XPathExpression xpathProjectName = xpath.compile(XPATH_PROJECT_NAME);
            NodeList projectNameNodes = (NodeList) xpathProjectName.evaluate(projectDocument, XPathConstants.NODESET);
            String projectName = projectNameNodes.item(0).getNodeValue();

            log.debug("project name = " + projectName);

            // gets project dependencies
            XPathExpression xpathProjectDependencies = xpath.compile(XPATH_PROJECT_DEPENDENCIES);
            NodeList projectDependenciesNodes = (NodeList) xpathProjectDependencies.evaluate(projectDocument, XPathConstants.NODESET);
            for (int i = 0, n = projectDependenciesNodes.getLength(); i < n; i++) {
                String supplier = projectDependenciesNodes.item(i).getNodeValue();
                projectDependencies.add(supplier);
            }

            // gets project natures
            XPathExpression xpathProjectNatures = xpath.compile(XPATH_PROJECT_NATURES);
            NodeList projectNaturesNodes = (NodeList) xpathProjectNatures.evaluate(projectDocument, XPathConstants.NODESET);
            for (int i = 0, n = projectNaturesNodes.getLength(); i < n; i++) {
                projectNatures.add(projectNaturesNodes.item(i).getNodeValue());
            }

            projectInfo.setProjectName(projectName);
            projectInfo.setProjectDependencies(projectDependencies);
            projectInfo.setProjectNatures(projectNatures);

        } catch (ParserConfigurationException |
                 SAXException |
                 XPathExpressionException |
                 IOException ex) {
            log.error("error parsing project file", ex);
            throw new AnalyzerException("error parsing project file", ex);
        }
    }

    /**
     * Analyzes the facet configuration file.
     *
     * @throws AnalyzerException any error occurred while analyzing the metadata
     *                           files, typically a parsing error in XML files
     */
    private void analyzeFacetsFile()
        throws AnalyzerException {

        List<String> projectFacets = new ArrayList<>();

        try {
            // for faceted projects, parses facet config file
            File facetConfigFile = new File(rootDir, FACET_CONFIG_FILE);
            if (!facetConfigFile.exists()) {
                return;
            }

            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            factory.setNamespaceAware(true);
            DocumentBuilder builder = factory.newDocumentBuilder();
            XPathFactory xpathFactory = XPathFactory.newInstance();
            XPath xpath = xpathFactory.newXPath();

            Document facetConfigDocument = builder.parse(facetConfigFile);

            // get fixed facets
            XPathExpression xpathFixedFacetEntry = xpath.compile(XPATH_FACET_FIXED);
            NodeList fixedFacetEntryNodes = (NodeList) xpathFixedFacetEntry.evaluate(facetConfigDocument, XPathConstants.NODESET);
            for (int i = 0, n = fixedFacetEntryNodes.getLength(); i < n; i++) {
                projectFacets.add(fixedFacetEntryNodes.item(i).getNodeValue());
            }

            // get installed facets
            XPathExpression xpathInstalledFacetEntry = xpath.compile(XPATH_FACET_INSTALLED);
            NodeList installedFacetEntryNodes = (NodeList) xpathInstalledFacetEntry.evaluate(facetConfigDocument, XPathConstants.NODESET);
            for (int i = 0, n = installedFacetEntryNodes.getLength(); i < n; i++) {
                projectFacets.add(installedFacetEntryNodes.item(i).getNodeValue());
            }

            projectInfo.setProjectFacets(projectFacets);

        } catch (ParserConfigurationException |
                 SAXException |
                 XPathExpressionException |
                 IOException ex) {
            log.error("error parsing project file", ex);
            throw new AnalyzerException("error parsing project file", ex);
        }
    }

    /**
     * Analyze the classpath file.
     *
     * @throws AnalyzerException any error occurred while analyzing the metadata
     *                           files, typically a parsing error in XML files
     */
    private void analyzeClasspathFile()
        throws AnalyzerException  {

        List<String> projectClasspath = new ArrayList<>();

        try {
            // parses .classpath file
            File classpathFile = new File(rootDir, CLASSPATH_FILE);
            if (!classpathFile.exists()) {
                return;
            }

            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            factory.setNamespaceAware(true);
            DocumentBuilder builder = factory.newDocumentBuilder();
            XPathFactory xpathFactory = XPathFactory.newInstance();
            XPath xpath = xpathFactory.newXPath();

            Document classpathDocument = builder.parse(classpathFile);

            // get libraries in classpath
            XPathExpression xpathClasspathLibEntry = xpath.compile(XPATH_CLASSPATH_LIB);
            NodeList classpathLibEntryNodes = (NodeList) xpathClasspathLibEntry.evaluate(classpathDocument, XPathConstants.NODESET);
            for (int i = 0, n = classpathLibEntryNodes.getLength(); i < n; i++) {
                String libName = classpathLibEntryNodes.item(i).getNodeValue();
                projectClasspath.add(libName);
            }

            // get source folders in classpath
            XPathExpression xpathClasspathSrcEntry = xpath.compile(XPATH_CLASSPATH_SRC);
            NodeList classpathSrcEntryNodes = (NodeList) xpathClasspathSrcEntry.evaluate(classpathDocument, XPathConstants.NODESET);
            for (int i = 0, n = classpathSrcEntryNodes.getLength(); i < n; i++) {
                String srcName = classpathSrcEntryNodes.item(i).getNodeValue();
                projectClasspath.add(srcName);
            }

            projectInfo.setProjectClasspath(projectClasspath);

        } catch (ParserConfigurationException |
                 SAXException |
                 XPathExpressionException |
                 IOException ex) {
            log.error("error parsing project file", ex);
            throw new AnalyzerException("error parsing project file", ex);
        }
    }
}
